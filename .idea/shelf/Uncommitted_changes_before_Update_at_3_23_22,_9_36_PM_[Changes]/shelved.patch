Index: src/edu/ufl/cise/plc/SymbolTable.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package edu.ufl.cise.plc;\n\nimport edu.ufl.cise.plc.ast.Declaration;\n\nimport java.util.HashMap;\nimport java.util.Objects;\n\npublic class SymbolTable {\n\n    // Implement a symbol table class that is appropriate for this language.\n    HashMap<String, Declaration> entries = new HashMap<>();\n    String programName;\n\n    public boolean insert(String name, Declaration dec) {\n        if (Objects.equals(name, programName)) return false;\n        return entries.putIfAbsent(name, dec) == null;\n    }\n\n    public Declaration lookup(String name) {\n        return entries.get(name);\n    }\n\n    public void setProgramName(String name) {\n        programName = name;\n    }\n\n    public boolean contains(String name) {\n        return entries.containsKey(name);\n    }\n\n\n}\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/edu/ufl/cise/plc/SymbolTable.java b/src/edu/ufl/cise/plc/SymbolTable.java
--- a/src/edu/ufl/cise/plc/SymbolTable.java	(revision 2f91bad39f271a4f35cf2d77e543b51269594870)
+++ b/src/edu/ufl/cise/plc/SymbolTable.java	(date 1648083963044)
@@ -27,8 +27,6 @@
     public boolean contains(String name) {
         return entries.containsKey(name);
     }
-
-
 }
 
 
Index: src/edu/ufl/cise/plc/TypeCheckVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package edu.ufl.cise.plc;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport edu.ufl.cise.plc.IToken.Kind;\nimport edu.ufl.cise.plc.ast.*;\nimport edu.ufl.cise.plc.ast.Types.Type;\n\nimport javax.naming.Name;\n\nimport static edu.ufl.cise.plc.ast.Types.Type.*;\n\npublic class TypeCheckVisitor implements ASTVisitor {\n\n\tSymbolTable symbolTable = new SymbolTable();\n\tProgram root;\n\t\n\trecord Pair<T0,T1>(T0 t0, T1 t1) {\n\n\t};  // may be useful for constructing lookup tables.\n\t\n\tprivate void check(boolean condition, ASTNode node, String message) throws TypeCheckException {\n\t\tif (!condition) {\n\t\t\tthrow new TypeCheckException(message, node.getSourceLoc());\n\t\t}\n\t}\n\t\n\t//The type of a BooleanLitExpr is always BOOLEAN.  \n\t//Set the type in AST Node for later passes (code generation)\n\t//Return the type for convenience in this visitor.  \n\t@Override\n\tpublic Object visitBooleanLitExpr(BooleanLitExpr booleanLitExpr, Object arg) throws Exception {\n\t\tbooleanLitExpr.setType(Type.BOOLEAN);\n\t\treturn Type.BOOLEAN;\n\t}\n\n\t@Override\n\tpublic Object visitStringLitExpr(StringLitExpr stringLitExpr, Object arg) throws Exception {\n\t\tstringLitExpr.setType(Type.STRING);\n\t\treturn Type.STRING;\n\t}\n\n\t@Override\n\tpublic Object visitIntLitExpr(IntLitExpr intLitExpr, Object arg) throws Exception {\n\t\tintLitExpr.setType(Type.INT);\n\t\treturn Type.INT;\n\t}\n\n\t@Override\n\tpublic Object visitFloatLitExpr(FloatLitExpr floatLitExpr, Object arg) throws Exception {\n\t\tfloatLitExpr.setType(Type.FLOAT);\n\t\treturn Type.FLOAT;\n\t}\n\n\t@Override\n\tpublic Object visitColorConstExpr(ColorConstExpr colorConstExpr, Object arg) throws Exception {\n\t\tcolorConstExpr.setType(Type.COLOR);\n\t\treturn Type.COLOR;\n\t}\n\n\t@Override\n\tpublic Object visitConsoleExpr(ConsoleExpr consoleExpr, Object arg) throws Exception {\n\t\tconsoleExpr.setType(Type.CONSOLE);\n\t\treturn Type.CONSOLE;\n\t}\n\t\n\t//Visits the child expressions to get their type (and ensure they are correctly typed)\n\t//then checks the given conditions.\n\t@Override\n\tpublic Object visitColorExpr(ColorExpr colorExpr, Object arg) throws Exception {\n\t\tType redType = (Type) colorExpr.getRed().visit(this, arg);\n\t\tType greenType = (Type) colorExpr.getGreen().visit(this, arg);\n\t\tType blueType = (Type) colorExpr.getBlue().visit(this, arg);\n\t\tcheck(redType == greenType && redType == blueType, colorExpr, \"color components must have same type\");\n\t\tcheck(redType == Type.INT || redType == Type.FLOAT, colorExpr, \"color component type must be int or float\");\n\t\tType exprType = (redType == Type.INT) ? Type.COLOR : Type.COLORFLOAT;\n\t\tcolorExpr.setType(exprType);\n\t\treturn exprType;\n\t}\t\n\n\t\n\t\n\t//Maps forms a lookup table that maps an operator expression pair into result type.  \n\t//This more convenient than a long chain of if-else statements. \n\t//Given combinations are legal; if the operator expression pair is not in the map, it is an error. \n\tMap<Pair<Kind,Type>, Type> unaryExprs = Map.of(\n\t\t\tnew Pair<Kind,Type>(Kind.BANG,BOOLEAN), BOOLEAN,\n\t\t\tnew Pair<Kind,Type>(Kind.MINUS, FLOAT), FLOAT,\n\t\t\tnew Pair<Kind,Type>(Kind.MINUS, INT),INT,\n\t\t\tnew Pair<Kind,Type>(Kind.COLOR_OP,INT), INT,\n\t\t\tnew Pair<Kind,Type>(Kind.COLOR_OP,COLOR), INT,\n\t\t\tnew Pair<Kind,Type>(Kind.COLOR_OP,IMAGE), IMAGE,\n\t\t\tnew Pair<Kind,Type>(Kind.IMAGE_OP,IMAGE), INT\n\t\t\t);\n\t\n\t//Visits the child expression to get the type, then uses the above table to determine the result type\n\t//and check that this node represents a legal combination of operator and expression type. \n\t@Override\n\tpublic Object visitUnaryExpr(UnaryExpr unaryExpr, Object arg) throws Exception {\n\t\t// !, -, getRed, getGreen, getBlue\n\t\tKind op = unaryExpr.getOp().getKind();\n\t\tType exprType = (Type) unaryExpr.getExpr().visit(this, arg);\n\t\t//Use the lookup table above to both check for a legal combination of operator and expression, and to get result type.\n\t\tType resultType = unaryExprs.get(new Pair<Kind,Type>(op,exprType));\n\t\tcheck(resultType != null, unaryExpr, \"incompatible types for unaryExpr\");\n\t\t//Save the type of the unary expression in the AST node for use in code generation later. \n\t\tunaryExpr.setType(resultType);\n\t\t//return the type for convenience in this visitor.\n\t\treturn resultType;\n\t}\n\n\n\t//This method has several cases. Work incrementally and test as you go. \n\t@Override\n\tpublic Object visitBinaryExpr(BinaryExpr binaryExpr, Object arg) throws Exception {\n\t\tKind op = binaryExpr.getOp().getKind();\n\t\tType lType = (Type) binaryExpr.getLeft().visit(this, arg);\n\t\tType rType = (Type) binaryExpr.getRight().visit(this, arg);\n\n\t\tType resultType = null;\n\t\tswitch (op) { // EQUALS, NOT_EQUALS, PLUS, MINUS, TIMES, DIV, MOD, LT, LE, GT, GE\n\t\t\tcase AND, OR -> {\n\t\t\t\tcheck(lType == Type.BOOLEAN && rType == Type.BOOLEAN, binaryExpr, \"Booleans required\");\n\t\t\t\tresultType = Type.BOOLEAN;\n\t\t\t}\n\t\t\tcase EQUALS, NOT_EQUALS -> {\n\t\t\t\tcheck(lType == rType, binaryExpr, \"Incompatible types for comparison\");\n\t\t\t\tresultType = Type.BOOLEAN;\n\t\t\t}\n\t\t\tcase PLUS, MINUS -> {\n\t\t\t\tif (lType == Type.INT && rType == Type.INT) {\n\t\t\t\t\tresultType = Type.INT;\n\t\t\t\t}\n\t\t\t\telse if (lType == Type.FLOAT && rType == Type.FLOAT) {\n\t\t\t\t\tresultType = Type.FLOAT;\n\t\t\t\t}\n\t\t\t\telse if (lType == Type.FLOAT && rType == Type.INT) {\n\t\t\t\t\t// Coerce to float\n\t\t\t\t\tbinaryExpr.getRight().setCoerceTo(Type.FLOAT);\n\t\t\t\t\tresultType = Type.FLOAT;\n\t\t\t\t}\n\t\t\t\telse if (lType == Type.INT && rType == Type.FLOAT) {\n\t\t\t\t\t// Coerce to float\n\t\t\t\t\tbinaryExpr.getLeft().setCoerceTo(Type.FLOAT);\n\t\t\t\t\tresultType = Type.FLOAT;\n\t\t\t\t}\n\t\t\t\telse if (lType == Type.COLOR && rType == Type.COLOR) {\n\t\t\t\t\tresultType = Type.COLOR;\n\t\t\t\t}\n\t\t\t\telse if (lType == Type.COLORFLOAT && rType == Type.COLORFLOAT) {\n\t\t\t\t\tresultType = Type.COLORFLOAT;\n\t\t\t\t}\n\t\t\t\telse if (lType == Type.COLORFLOAT && rType == Type.COLOR) {\n\t\t\t\t\t// Coerce to colorfloat\n\t\t\t\t\tbinaryExpr.getRight().setCoerceTo(Type.COLORFLOAT);\n\t\t\t\t\tresultType = Type.COLORFLOAT;\n\t\t\t\t}\n\t\t\t\telse if (lType == Type.COLOR && rType == Type.COLORFLOAT) {\n\t\t\t\t\t// Coerce to colorfloat\n\t\t\t\t\tbinaryExpr.getLeft().setCoerceTo(Type.COLORFLOAT);\n\t\t\t\t\tresultType = Type.COLORFLOAT;\n\t\t\t\t}\n\t\t\t\telse if (lType == Type.IMAGE && rType == Type.IMAGE) {\n\t\t\t\t\tresultType = Type.IMAGE;\n\t\t\t\t}\n\t\t\t\telse check(false, binaryExpr, \"incompatible types for operator\");\n\t\t\t}\n\t\t\tcase TIMES, DIV, MOD -> {\n\t\t\t\tif (lType == Type.IMAGE && rType == Type.INT) {\n\t\t\t\t\tresultType = Type.IMAGE;\n\t\t\t\t}\n\t\t\t\telse if (lType == Type.IMAGE && rType == Type.FLOAT) {\n\t\t\t\t\tresultType = Type.IMAGE;\n\t\t\t\t}\n\t\t\t\telse if (lType == Type.INT && rType == Type.COLOR) {\n\t\t\t\t\tbinaryExpr.getLeft().setCoerceTo(Type.COLOR);\n\t\t\t\t\tresultType = Type.COLOR;\n\t\t\t\t}\n\t\t\t\telse if (lType == Type.COLOR && rType == Type.INT) {\n\t\t\t\t\tbinaryExpr.getRight().setCoerceTo(Type.COLOR);\n\t\t\t\t\tresultType = Type.COLOR;\n\t\t\t\t}\n\t\t\t\telse if (lType == Type.FLOAT && rType == Type.COLOR) {\n\t\t\t\t\tbinaryExpr.getLeft().setCoerceTo(Type.COLORFLOAT);\n\t\t\t\t\tbinaryExpr.getRight().setCoerceTo(Type.COLORFLOAT);\n\t\t\t\t\tresultType = Type.COLORFLOAT;\n\t\t\t\t}\n\t\t\t\telse check(false, binaryExpr, \"incompatible types for operator\");\n\t\t\t}\n\t\t\tcase LT, LE, GT, GE -> {\n\t\t\t\tif (lType == Type.INT && rType == Type.INT) {\n\t\t\t\t\tresultType = Type.BOOLEAN;\n\t\t\t\t}\n\t\t\t\telse if (lType == Type.FLOAT && rType == Type.FLOAT) {\n\t\t\t\t\tresultType = Type.BOOLEAN;\n\t\t\t\t}\n\t\t\t\telse if (lType == Type.INT && rType == Type.FLOAT) {\n\t\t\t\t\tbinaryExpr.getLeft().setCoerceTo(Type.FLOAT);\n\t\t\t\t\tresultType = Type.BOOLEAN;\n\t\t\t\t}\n\t\t\t\telse if (lType == Type.FLOAT && rType == Type.INT) {\n\t\t\t\t\tbinaryExpr.getRight().setCoerceTo(Type.FLOAT);\n\t\t\t\t\tresultType = Type.BOOLEAN;\n\t\t\t\t}\n\t\t\t\telse check(false, binaryExpr, \"incompatible types for operator\");\n\t\t\t}\n\t\t\tdefault -> check(false, binaryExpr, \"use a real operator\");\n\t\t}\n\t\tbinaryExpr.setType(resultType);\n\t\treturn resultType;\n\t}\n\n\t@Override\n\tpublic Object visitIdentExpr(IdentExpr identExpr, Object arg) throws Exception {\n\t\tString name = identExpr.getText();\n\t\tDeclaration dec = symbolTable.lookup(name);\n\t\tcheck(dec != null, identExpr, \"Undefined identifier \" + name);\n\t\tcheck(dec.isInitialized(), identExpr, \"Uninitialized identifier used: \" + name);\n\n\t\tidentExpr.setDec(dec); // Useful later, apparently\n\n\t\tType type = dec.getType();\n\t\tidentExpr.setType(type);\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic Object visitConditionalExpr(ConditionalExpr conditionalExpr, Object arg) throws Exception {\n\t\tType conditionCase = (Type) symbolTable.lookup(conditionalExpr.getCondition().getText()).visit(this, arg);\n\t\tType trueCase = (Type) symbolTable.lookup(conditionalExpr.getTrueCase().getText()).visit(this, arg);\n\t\tType falseCase = (Type) symbolTable.lookup(conditionalExpr.getFalseCase().getText()).visit(this, arg);\n\n\t\tcheck(conditionCase == Type.BOOLEAN, conditionalExpr, \"Condition case must be boolean\");\n\t\tcheck(trueCase == falseCase, conditionalExpr, \"True case must equal false case\");\n\n\t\tconditionalExpr.setType(trueCase);\n\t\treturn trueCase;\n\t}\n\n\t@Override\n\tpublic Object visitDimension(Dimension dimension, Object arg) throws Exception {\n\t\tType expr1Type = (Type) dimension.getWidth().visit(this, arg);\n\t\tType expr2Type = (Type) dimension.getHeight().visit(this, arg);\n\n\t\tcheck(expr1Type == Type.INT, dimension.getWidth(), \"Width is not of type int!\");\n\t\tcheck(expr2Type == Type.INT, dimension.getHeight(), \"Height is not of type int!\");\n\t\treturn null;\n\t}\n\n\t@Override\n\t//This method can only be used to check PixelSelector objects on the right hand side of an assignment. \n\t//Either modify to pass in context info and add code to handle both cases, or when on left side\n\t//of assignment, check fields from parent assignment statement.\n\tpublic Object visitPixelSelector(PixelSelector pixelSelector, Object arg) throws Exception {\n\t\tType xType = (Type) pixelSelector.getX().visit(this, arg);\n\t\tcheck(xType == Type.INT, pixelSelector.getX(), \"only ints as pixel selector components\");\n\t\tType yType = (Type) pixelSelector.getY().visit(this, arg);\n\t\tcheck(yType == Type.INT, pixelSelector.getY(), \"only ints as pixel selector components\");\n\t\treturn null;\n\t}\n\n\t@Override\n\t//This method several cases--you don't have to implement them all at once.\n\t//Work incrementally and systematically, testing as you go.  \n\tpublic Object visitAssignmentStatement(AssignmentStatement assignmentStatement, Object arg) throws Exception {\n\t\t//TODO:  implement this method\n\t\tType targetType = symbolTable.lookup(assignmentStatement.getName()).getType();\n\t\tthrow new UnsupportedOperationException(\"Unimplemented visit method.\");\n\t}\n\n\n\t@Override\n\tpublic Object visitWriteStatement(WriteStatement writeStatement, Object arg) throws Exception {\n\t\tType sourceType = (Type) writeStatement.getSource().visit(this, arg);\n\t\tType destType = (Type) writeStatement.getDest().visit(this, arg);\n\t\tcheck(destType == Type.STRING || destType == Type.CONSOLE, writeStatement,\n\t\t\t\t\"illegal destination type for write\");\n\t\tcheck(sourceType != Type.CONSOLE, writeStatement, \"illegal source type for write\");\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Object visitReadStatement(ReadStatement readStatement, Object arg) throws Exception {\n\t\t//TODO:  implement this method\n\t\tthrow new UnsupportedOperationException(\"Unimplemented visit method.\");\n\t}\n\n\t@Override\n\tpublic Object visitVarDeclaration(VarDeclaration declaration, Object arg) throws Exception {\n\t\tType nameType = (Type) declaration.getNameDef().visit(this, arg);\n\t\tboolean isInitialized = declaration.getNameDef().isInitialized();\n\n\t\tif (isInitialized) {\n\t\t\tExpr expr = declaration.getExpr();\n\t\t\tType exprType = expr.getType();\n\n\t\t\tif (nameType == Type.IMAGE) {\n\t\t\t\tif (exprType == Type.INT) {\n\t\t\t\t\texpr.setCoerceTo(Type.COLOR);\n\t\t\t\t} else if (exprType == Type.FLOAT) {\n\t\t\t\t\texpr.setCoerceTo(Type.COLORFLOAT);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nameType == Type.INT && exprType == Type.FLOAT) {\n\t\t\t\texpr.setCoerceTo(Type.INT);\n\t\t\t} else if (nameType == Type.FLOAT && exprType == Type.INT) {\n\t\t\t\texpr.setCoerceTo(Type.FLOAT);\n\t\t\t} else if (nameType == Type.INT && exprType == Type.COLOR) {\n\t\t\t\texpr.setCoerceTo(Type.INT);\n\t\t\t} else if (nameType == Type.COLOR && exprType == Type.INT) {\n\t\t\t\texpr.setCoerceTo(Type.COLOR);\n\t\t\t}\n\n\t\t\tboolean valid1 = nameType == Type.IMAGE && expr.getCoerceTo() == Type.COLOR || nameType == Type.IMAGE && exprType == Type.COLOR ||\n\t\t\t\t\tnameType == Type.IMAGE && expr.getCoerceTo() == Type.COLORFLOAT || nameType == Type.IMAGE && exprType == Type.COLORFLOAT;\n\t\t\tboolean valid2 = nameType == expr.getCoerceTo() || nameType == exprType;\n\n\t\t\tcheck(valid1 || valid2, declaration, \"Types of LHS and RHS are not compatible!\");\n\t\t}\n\n\t\treturn declaration.getNameDef().getType();\n\t}\n\n\n\t@Override\n\tpublic Object visitProgram(Program program, Object arg) throws Exception {\n\t\t\n\t\t// Save root of AST so return type can be accessed in return statements\n\t\troot = program;\n\n\t\t// Add program name to symbol table (Mark name as initialized)\n\t\tString programName = program.getName();\n\t\tsymbolTable.setProgramName(programName);\n\n\t\t// Check parameters\n\t\tList<NameDef> parameters = program.getParams();\n\t\tfor (NameDef nameDef : parameters) {\n\t\t\tnameDef.visit(this, arg);\n\t\t}\n\n\t\t// Check declarations and statements\n\t\tList<ASTNode> decsAndStatements = program.getDecsAndStatements();\n\t\tfor (ASTNode node : decsAndStatements) {\n\t\t\tnode.visit(this, arg);\n\t\t}\n\n\t\treturn program;\n\t}\n\n\t@Override\n\tpublic Object visitNameDef(NameDef nameDef, Object arg) throws Exception {\n\t\tboolean unique = symbolTable.insert(nameDef.getName(), nameDef);\n\t\tcheck(unique, nameDef, \"Variable declared twice!\");\n\n\t\treturn nameDef.getType();\n\t}\n\n\t@Override\n\tpublic Object visitNameDefWithDim(NameDefWithDim nameDefWithDim, Object arg) throws Exception {\n\t\tboolean unique = symbolTable.insert(nameDefWithDim.getName(), nameDefWithDim);\n\t\tcheck(unique, nameDefWithDim, \"Variable declared twice!\");\n\n\t\treturn nameDefWithDim.getType();\n\t}\n \n\t@Override\n\tpublic Object visitReturnStatement(ReturnStatement returnStatement, Object arg) throws Exception {\n\t\tType returnType = root.getReturnType();  //This is why we save program in visitProgram.\n\t\tType expressionType = (Type) returnStatement.getExpr().visit(this, arg);\n\t\tcheck(returnType == expressionType, returnStatement, \"return statement with invalid type\");\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Object visitUnaryExprPostfix(UnaryExprPostfix unaryExprPostfix, Object arg) throws Exception {\n\t\tType expType = (Type) unaryExprPostfix.getExpr().visit(this, arg);\n\t\tcheck(expType == Type.IMAGE, unaryExprPostfix, \"pixel selector can only be applied to image\");\n\t\tunaryExprPostfix.getSelector().visit(this, arg);\n\t\tunaryExprPostfix.setType(Type.INT);\n\t\tunaryExprPostfix.setCoerceTo(COLOR);\n\t\treturn Type.COLOR;\n\t}\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/edu/ufl/cise/plc/TypeCheckVisitor.java b/src/edu/ufl/cise/plc/TypeCheckVisitor.java
--- a/src/edu/ufl/cise/plc/TypeCheckVisitor.java	(revision 2f91bad39f271a4f35cf2d77e543b51269594870)
+++ b/src/edu/ufl/cise/plc/TypeCheckVisitor.java	(date 1648085316625)
@@ -103,7 +103,7 @@
 		Kind op = unaryExpr.getOp().getKind();
 		Type exprType = (Type) unaryExpr.getExpr().visit(this, arg);
 		//Use the lookup table above to both check for a legal combination of operator and expression, and to get result type.
-		Type resultType = unaryExprs.get(new Pair<Kind,Type>(op,exprType));
+		Type resultType = unaryExprs.get(new Pair<>(op, exprType));
 		check(resultType != null, unaryExpr, "incompatible types for unaryExpr");
 		//Save the type of the unary expression in the AST node for use in code generation later. 
 		unaryExpr.setType(resultType);
@@ -266,7 +266,7 @@
 	//Work incrementally and systematically, testing as you go.  
 	public Object visitAssignmentStatement(AssignmentStatement assignmentStatement, Object arg) throws Exception {
 		//TODO:  implement this method
-		Type targetType = symbolTable.lookup(assignmentStatement.getName()).getType();
+
 		throw new UnsupportedOperationException("Unimplemented visit method.");
 	}
 
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"ef58fd28-b9f4-4d89-a35f-7b258833c9de\" name=\"Changes\" comment=\"Returns TypeCheckVisitor so tests can run properly\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/edu/ufl/cise/plc/CompilerComponentFactory.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/edu/ufl/cise/plc/CompilerComponentFactory.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/edu/ufl/cise/plc/SymbolTable.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/edu/ufl/cise/plc/SymbolTable.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/edu/ufl/cise/plc/TypeCheckVisitor.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/edu/ufl/cise/plc/TypeCheckVisitor.java\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"CodeStyleSettingsInfer\">\n    <option name=\"done\" value=\"true\" />\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"MarkdownSettingsMigration\">\n    <option name=\"stateVersion\" value=\"1\" />\n  </component>\n  <component name=\"ProjectCodeStyleSettingsMigration\">\n    <option name=\"version\" value=\"2\" />\n  </component>\n  <component name=\"ProjectId\" id=\"26lG92QAwg8qiss9K3DqR5ZfhFI\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">\n    <property name=\"Downloaded.Files.Path.Enabled\" value=\"false\" />\n    <property name=\"Repository.Attach.Annotations\" value=\"false\" />\n    <property name=\"Repository.Attach.JavaDocs\" value=\"false\" />\n    <property name=\"Repository.Attach.Sources\" value=\"false\" />\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$\" />\n    <property name=\"project.structure.last.edited\" value=\"Libraries\" />\n    <property name=\"project.structure.proportion\" value=\"0.15\" />\n    <property name=\"project.structure.side.proportion\" value=\"0.2\" />\n  </component>\n  <component name=\"RunManager\" selected=\"JUnit.StarterTests\">\n    <configuration name=\"Assignment3StarterTest\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"COP4020Project\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"edu.ufl.cise.plc.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <option name=\"PACKAGE_NAME\" value=\"edu.ufl.cise.plc\" />\n      <option name=\"MAIN_CLASS_NAME\" value=\"edu.ufl.cise.plc.Assignment3StarterTest\" />\n      <option name=\"TEST_OBJECT\" value=\"class\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"StarterTests\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"COP4020Project\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"edu.ufl.cise.plc.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <option name=\"PACKAGE_NAME\" value=\"edu.ufl.cise.plc\" />\n      <option name=\"MAIN_CLASS_NAME\" value=\"edu.ufl.cise.plc.StarterTests\" />\n      <option name=\"TEST_OBJECT\" value=\"class\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue=\"JUnit.StarterTests\" />\n        <item itemvalue=\"JUnit.Assignment3StarterTest\" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"ef58fd28-b9f4-4d89-a35f-7b258833c9de\" name=\"Changes\" comment=\"\" />\n      <created>1647990604776</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1647990604776</updated>\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"Returns TypeCheckVisitor so tests can run properly\">\n      <created>1648076988189</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1648076988189</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"2\" />\n    <servers />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"Returns TypeCheckVisitor so tests can run properly\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Returns TypeCheckVisitor so tests can run properly\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 2f91bad39f271a4f35cf2d77e543b51269594870)
+++ b/.idea/workspace.xml	(date 1648085292865)
@@ -6,7 +6,6 @@
   <component name="ChangeListManager">
     <list default="true" id="ef58fd28-b9f4-4d89-a35f-7b258833c9de" name="Changes" comment="Returns TypeCheckVisitor so tests can run properly">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/edu/ufl/cise/plc/CompilerComponentFactory.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/edu/ufl/cise/plc/CompilerComponentFactory.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/edu/ufl/cise/plc/SymbolTable.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/edu/ufl/cise/plc/SymbolTable.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/edu/ufl/cise/plc/TypeCheckVisitor.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/edu/ufl/cise/plc/TypeCheckVisitor.java" afterDir="false" />
     </list>
@@ -43,6 +42,7 @@
     <property name="project.structure.last.edited" value="Libraries" />
     <property name="project.structure.proportion" value="0.15" />
     <property name="project.structure.side.proportion" value="0.2" />
+    <property name="settings.editor.selected.configurable" value="preferences.pluginManager" />
   </component>
   <component name="RunManager" selected="JUnit.StarterTests">
     <configuration name="Assignment3StarterTest" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
